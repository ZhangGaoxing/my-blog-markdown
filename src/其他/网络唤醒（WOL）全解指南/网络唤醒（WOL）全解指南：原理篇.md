## 什么是网络唤醒

网络唤醒（Wake-on-LAN，WOL）是一种计算机局域网唤醒技术，使局域网内处于关机或休眠状态的计算机，将状态转换成引导（Boot Loader）或运行状态。无线唤醒（Wake-on-Wireless-LAN，WoWLAN）作为 WOL 的补充技术，使用无线网卡去唤醒计算机。网络唤醒在一般的局域网环境里使用**有限广播地址**（255.255.255.255）即可，由于路由器都不转发目的地址为有限广播地址的数据报，因此在复杂网络情况下通常使用**子网定向广播地址**。在局域网外唤醒局域网内特定计算机，可以使用路由器的 DDNS 与端口转发。

在1996年10月，英特尔和 IBM 成立了 Advanced Manageability Alliance。1997年4月，联盟提出了 WOL 技术。这是 WOL 技术的起源，随后各大厂商纷纷推出了自己的 WOL 技术标准。本文所讨论的 WOL 技术是由 AMD 公司提出的 Magic Packet（幻数据包，魔术包）唤醒方式，这里给出 AMD 关于此技术的[白皮书](https://support.amd.com/TechDocs/20213.pdf)。

## 幻数据包（Magic Packet）

幻数据包是一个广播帧，包含目标计算机的MAC地址。由于 MAC 地址的唯一性，使数据包可以在网络中被唯一的识别。幻数据包发送通常使用无连接的传输协议，如 UDP ，发送端口为 7 或 9，这只是通常做法，没有限制。

WOL 技术被提出了将近20年，绝大多数的现代网卡都支持在超低功耗下监听特定的报文，如 ARP。如果设备网卡接收到一个与自己 MAC 地址相同的幻数据包，则网卡会向计算机的电源或主板发出信号以唤醒计算机。大部分的幻数据包在数据链路层（OSI模型第2层）上发送，当发送时，使用广播地址广播到给定的网络上，不使用IP地址（OSI模型第3层）。当然这是绝大部分情况，幻数据包也可以使用特定的 IP 地址进行发送。

幻数据包最简单的构成是 6 字节的 255（FF FF FF FF FF FF FF），紧接着为目标计算机的 48 位 MAC 地址，重复 16 次，数据包共计 102 字节。有时数据包内还会紧接着 4-6 字节的密码信息。这个帧片段可以包含在任何协议中，最常见的是包含在 UDP 中。

| FF FF FF FF FF FF FF | MAC 地址 × 16 | 4-6 字节的密码（可空） |
|-|-|-|

例如 MAC 地址为 11 22 33 44 55 66 的目标计算机，幻数据包的格式为：
```
FFFFFFFFFFFF 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 112233445566 [ABABABABABAB（这里为6个字节的密码）]
```

幻数据包还有一些基本限制条件：

1. 需要知道目标计算机 MAC 地址
2. 不提供送达确认
3. 可能无法在局域网之外工作
4. 需要硬件进行支持

## 创建幻数据包

项目地址：[https://github.com/ZhangGaoxing/wake-on-lan](https://github.com/ZhangGaoxing/wake-on-lan)

该项目为 Xamarin 跨平台项目，支持自动扫描添加局域网设备。

关于 MAC 地址的扫描获取，这里只说一下思路，详细请查阅代码。第一种方式：使用 Ping 命令扫描整个网段的设备，此方法稍微有点慢，而且 .NET 的 Ping 类在 Android 上无法限制秒数。第二种方式：直接向整个网段发送 UDP 消息，扫描完成后读取 ARP 表即可获取网段内设备的 MAC 地址。

下面给出的是发送幻数据包的方法：

```C#
public static async void Wake(string broadcast, int port, byte[] mac)
{
    using (UdpClient udp = new UdpClient())
    {
        udp.EnableBroadcast = true;

        byte[] packet = new byte[6 + 16 * 6];

        for (int i = 0; i < 6; i++)
        {
            packet[i] = 0xFF;
        }

        for (int i = 0; i < 16; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                packet[6 + i * 6 + j] = mac[j];
            }
        }

        await udp.SendAsync(packet, packet.Length, broadcast, port);
    }
}
```
