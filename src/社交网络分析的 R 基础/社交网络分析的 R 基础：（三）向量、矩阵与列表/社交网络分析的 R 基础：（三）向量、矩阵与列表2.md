<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

* [矩阵]()
  * [矩阵的创建]()
  * [矩阵元素的访问]()
  * [矩阵的运算]()
  * [矩阵的特征值与特征向量]()

## 矩阵

### 矩阵的创建

矩阵（matrix）作为社交网络分析中的一个重要工具，其并不算是一个基本的数据结构。你可以将矩阵看成一个二维数组（array），或是由多个向量（vector）构成。在 R 语言中使用 `matrix()` 函数来创建矩阵。
```R
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
```
其中 `data` 表示矩阵的填充元素，`nrow` 表示矩阵的行数，`ncol` 表示矩阵的列数，`byrow` 表示 `data` 的值是否按行填充，`dimnames` 给矩阵行列的名称赋值。

```R
> matrix(c(1:6), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c("r1", "r2"), c("c1", "c2", "c3")))
   c1 c2 c3
r1  1  2  3
r2  4  5  6
```
上面即创建了一个 2 行 3 列的矩阵，通过按行填充元素的方式，并且给行和列赋予了名称。获取矩阵的行数和列数可以使用函数 `nrow()` 和 `ncol()`。

矩阵还可以通过组合向量的方式创建，使用 `rbind()` 函数按行组合向量，使用 `cbind()` 函数按列组合向量：
```R
> v1 <- c(1:3)
> v2 <- c(4:6)
> v3 <- c(7:9)

> rbind(v1, v2, v3)  # 按行组合
   [,1] [,2] [,3]
v1    1    2    3
v2    4    5    6
v3    7    8    9

> cbind(v1, v2, v3)  # 按列组合
     v1 v2 v3
[1,]  1  4  7
[2,]  2  5  8
[3,]  3  6  9
```

### 矩阵元素的访问

矩阵中的元素通过“`[行索引, 列索引]`”的形式访问。
```R
> m <- matrix(c(1:6), nrow = 3)
> m[3, 2]
[1] 6
```

想要从矩阵中取出行向量或者列向量，使用“`[行索引,]`”或者“`[,列索引]`”。
```R
> m[1,]  # 取第一行
[1] 1 4

> m[,2]  # 取第二列
[1] 4 5 6
```

在给矩阵的行列赋值名称后，可以使用名称索引访问。
```R
> rownames(m) <- c("r1", "r2", "r3")  # 定义行的名称
> colnames(m) <- c("c1", "c2")  # 定义列的名称

> m["r2", "c2"]
[1] 5
```

### 矩阵的运算

矩阵直接进行算术运算时，是两个矩阵**对应位置的元素**做运算。数学函数和统计函数在矩阵中的用法与在向量中的用法相同。
```R
> m1 <- matrix(c(1:4), nrow = 2)
> m2 <- matrix(c(5:8), nrow = 2)
> m1 * m2
     [,1] [,2]
[1,]    5   21
[2,]   12   32
```

矩阵还包括一些特有的运算，比如内积 `%*%`，外积 `%o%`。
```R
> m1 <- matrix(c(1:6), nrow = 2)
> m2 <- matrix(c(1:6), nrow = 3)
> m1 %*% m2  # 矩阵的内积
     [,1] [,2]
[1,]   22   49
[2,]   28   64

> m1 <- c(1, 2, 3)
> m2 <- c(4, 5, 6)
> m1 %o% m2  # 矩阵的外积
     [,1] [,2] [,3]
[1,]    4    5    6
[2,]    8   10   12
[3,]   12   15   18
```

矩阵的转置使用函数 `t()`。
```R
> m <- matrix(c(1:4), nrow = 2)
> t(m)
     [,1] [,2]
[1,]    1    2
[2,]    3    4
```

### 矩阵的特征值与特征向量

特征值与特征向量作为矩阵的重要属性，不仅在传统的图分析中有重要的意义，在图卷积中也有重要的应用。R 语言为我们提供了计算函数 `eigen()`：
```R
> v1 <- c(1, 0, 0)
> v2 <- c(2, 3, 0)
> v3 <- c(4, 5, 6)
> m <- cbind(v1, v2, v3)

> eigen(m)              
eigen() decomposition
$values  # 特征值
[1] 6 3 1

$vectors  # 特征向量
          [,1]      [,2] [,3]
[1,] 0.6023442 0.7071068    1
[2,] 0.6844821 0.7071068    0
[3,] 0.4106893 0.0000000    0
```

随着网络规模的变大，`eigen()` 函数的计算速度会变得很慢，此时通常会使用 `RSpectra` 包来加快计算速度。在 `RSpectra` 包中使用 `eigs()` 函数计算特征值与特征向量：
```R
> library(RSpectra)
> eigs(m, 3)  # 这里的 3 是指要计算特征值与特征向量的个数
$values
[1] 6 3 1

$vectors
          [,1]      [,2] [,3]
[1,] 0.6023442 0.7071068    1
[2,] 0.6844821 0.7071068    0
[3,] 0.4106893 0.0000000    0
```

当网络规模继续变大，邻接矩阵中的节点数量到达数十万以上的规模时，`RSpectra` 包仍然有些捉襟见肘。这时使用 `Rcpp` 包调用 C++ 的代码，采用并行计算的方式加快计算速度。对于矩阵的计算操作，安装 `Rcpp` 包的同时还需要安装 `RcppEigen` 包。依赖的包安装完成后，新建一个 `matrix.cpp` 文件，将下面的代码复制到该文件中保存。
```cpp
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>

// [[Rcpp::export]]
SEXP eigenValues(const Eigen::Map<Eigen::MatrixXd> A){
    Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(A);
    return Rcpp::wrap(es.eigenvalues());
}

// [[Rcpp::export]]
SEXP eigenVectors(const Eigen::Map<Eigen::MatrixXd> A){
    Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(A);
    return Rcpp::wrap(es.eigenvectors());
}
```

紧接着在工作区中引入 `Rcpp` 包与 `matrix.cpp` 文件，此时就可以调用特征值计算函数 `eigenValues()` 和特征向量计算函数 `eigenVectors()`。

```R
> library(Rcpp)
> sourceCpp("matrix.cpp")
> eigenValues(m)
[1] 1 3 6
> eigenVectors(m)  
     [,1]      [,2]      [,3]
[1,]    1 0.7071068 0.6023442
[2,]    0 0.7071068 0.6844821
[3,]    0 0.0000000 0.4106893
```

## 参考

1. <a id="1" target="_blank" href="https://cran.r-project.org/doc/manuals/r-release/R-intro.html">An Introduction to R</a>
2. <a id="2" target="_blank" href="https://www.runoob.com/r/r-matrix.html">R 矩阵 | 菜鸟教程</a>